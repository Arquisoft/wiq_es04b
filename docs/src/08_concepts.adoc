ifndef::imagesdir[:imagesdir: ../images]

[[section-concepts]]
== Cross-cutting Concepts

The following concepts provide a foundation for the design and implementation of the trivia game project, which utilizes the Wikidata API for dynamic question generation and employs a hexagonal architecture for its Java Spring Boot application.

=== Domain Model

The domain model for our game includes entities such as `Question`, `Category`, `Player`, `Role`, and `GameSession`. These are crucial for representing the game's data and logic. The model serves as the basis for interactions within the application and between the application and the database.


[plantuml, domain-model, svg, subs="attributes", subs="methods"]
----
@startuml
class Question {
  - id: Long
  - statement: String
  - options: List<Answer>
  - correctAnswer: Answer
  - category: Category
  + addOption(option: Answer): void
  + removeOption(option: Answer): void
  + getOption(index: int): Answer
  + isCorrectAnswer(answer: Answer): boolean
  + scrambleOptions(): void
  + equals(o: Object): boolean
  + hashCode(): int
  + toString(): String
  + toJson(): JsonNode
}

class Category {
  - id: Long
  - name: String
  - questions: Set<Question>
  + toString(): String
  + toJson(): JsonNode
}

class Player {
  - id: Long
  - username: String
  - email: String
  - password: String
  - passwordConfirm : String
  - roles: Set<Role>
  - gameSessions: Set<GameSession>
  - apiKey: ApiKey
  + toJson(): JsonNode
}

class GameSession {
  - id: Long
  - player: Player
  - correctQuestions: Integer
  - totalQuestions: Integer
  - createdAt: LocalDateTime
  - finishTime: LocalDateTime
  - score: int
  + addQuestion(correct: boolean): void
  + toJson(): JsonNode
}

class Role {
    - name: String
    - players: Set<Player>
}

class Answer {
    - id: Long
    - text: String
    - correct: boolean
    - question: Question
    + toString(): String
    + toJson(): JsonNode
}

class ApiKey {
    - id: Long
    - keyToken: String
    - player: Player
    - accessLogs: Set<RestApiAccessLog>
}

class Associations {

}

class PlayerRole {
    + addRole(player: Player, role: Role): void
    + removeRole(player: Player, role: Role): void
}

class PlayerApiKey {
    + addApiKey(player: Player, apiKey: ApiKey): void
    + removeApiKey(player: Player, apiKey: ApiKey): void
}

class ApiKeyAccessLog {
    + addAccessLog(apiKey: ApiKey, accessLog: RestApiAccessLog): void
    + removeAccessLog(apiKey: ApiKey, accessLog: RestApiAccessLog): void
}

class PlayerGameSession {
    + addGameSession(player: Player, gameSession: GameSession): void
    + removeGameSession(player: Player, gameSession: GameSession): void
}

class QuestionAnswers {
    + addAnswer(question: Question, answer: List<Answer>): void
    + removeAnswer(question: Question, answer: List<Answer>): void
}

class RestApiAccessLog {
    - id: Long
    - apiKey: ApiKey
    - path: String
    - details: String
}

interface JsonEntity {
    + toJson(): JsonNode
}

interface PlayerService {
    + addNewPlayer(dto: PlayerDto): Player
    + getUsers(): List<Player>
    + getUser(id: Long): Optional<Player>
    + getUserByEmail(email: String): Optional<Player>
    + getUserByUsername(username: String): Optional<Player>
    + getUsersByRole(role: String): List<Player>
    + generateapiKey(player: Player): void
}

interface RoleService {
    + addRole(role: RoleDto): Role
    + getRole(name: String): Role
    + getRoles(): List<Role>
}

interface AnswerService {
    + addNewAnswer(answer: Answer): void
    + getAnswerPerQuestion(question: Question): List<Answer>
    + getAnswer(id: Long): Optional<Answer>
}

interface ApiKeyService {
    + createApiKey(forPlayer: Player): ApiKey
    + getApiKey(apiKey: String): ApiKey
}

interface CategoryService {
    + addNewCategory(category: Category): void
    + getAllCategories(): List<Category>
    + getCategory(id: Long): Optional<Category>
    + getCategoryByName(geography: String): Category
}

interface QuestionService {
    + addNewQuestion(question: Question): void
    + getAllQuestions(): List<Question>
    + getQuestion(id: Long): Optional<Question>
}

interface RestApiService {
    + getPlayers(params: Map<String, String>): List<Player>
    + logAccess(apiKey: ApiKey, path: String, params: Map<String, String>): void
    + getQuestions(params: Map<String, String>): List<Question>
}

class CustomUserDetailsService {
    - playerRepository: PlayerRepository
    + loadUserByUsername(username: String): UserDetails
    + mapRolesToAuthorities(roles: Collection<Role>): Collection< ? extends GrantedAuthority>
}

class InsertSampleDataService {
    - playerService: PlayerService
    - questionService: QuestionService
    - categoryService: CategoryService
    - questionRepository: QuestionRepository
    - gameSessionRepository: GameSessionRepository
    + insertSampleQuestions(): void
}

class PlayerServiceImpl {
    - playerRepository: PlayerRepository
    - roleService: RoleService
    - passwordEncoder: PasswordEncoder
    + addNewPlayer(dto: PlayerDto): Player
    + getUsers(): List<Player>
    + getUser(id: Long): Optional<Player>
    + getUserByEmail(email: String): Optional<Player>
    + getUserByUsername(username: String): Optional<Player>
    + getUsersByRole(role: String): List<Player>
    + generateApiKey(player: Player): void
}

class RoleServiceImpl {
    - roleRepository: RoleRepository
    + addRole(role: RoleDto): Role
    + getRole(name: String): Role
    + getRoles(): List<Role>
}

class AnswerServiceImpl {
    - answerRepository: AnswerRepository
    + addNewAnswer(answer: Answer): void
    + getAnswersPerQuestion(question: Question): List<Answer>
    + getAnswer(id: Long): Optional<Answer>
}

class ApiKeyServiceImpl {
    - apiKeyRepository: ApiKeyRepository
    + createApiKey(forPlayer: Player): ApiKey
    + getApiKey(apiKey: String): ApiKey
}

class CategoryServiceImpl {
    - categoryRepository: CategoryRepository
    + addNewCategory(category: Category): void
    + getAllCategories(): List<Category>
    + getCategory(id: Long): Optional<Category>
    + getCategoryByName(name: String): Category
    + init(): void
}

class QuestionServiceImpl {
    - questionRepository: QuestionRepository
    + addNewQuestion(question: Question): void
    + getAllQuestions(): List<Question>
    + getQuestion(id: Long): Optional<Question>
}

class RestApiServiceImpl {
    - playerService: PlayerService
    - restApiLogRepository: RestApiLogRepository
    - questionService: QuestionService
    + getPlayers(params: Map<String, String>): List<Player>
    + logAccess(apiKey: ApiKey, path: String, params: Map<String, String>): void
    + getQuestions(params: Map<String, String>): List<Question>
}

interface CrudRepository {
    + save(entity: T): T
    + findById(id: ID): Optional<T>
    + findAll(): List<T>
}

interface PlayerRepository {
    + findByEmail(email: String): Player
    + findByUsername(nickname: String): Player
}

interface RoleRepository {
}

interface AnswerRepository {
    + findByQuestion(question: Question): List<Answer>
}

interface ApiKeyRepository {
    + findByKeyToken(key: String): ApiKey
}

interface CategoryRepository {
    + findByName(name: String): Category
}

interface GameSessionRepository {
}

interface QuestionRepository {
    + findByStatement(statement: String): Question
}

interface RestApiLogRepository {
    + findByApiKey(apiKey: ApiKey): List<RestApiAccessLog>
    + findByUser(user: Player): List<RestApiAccessLog>
}

class PlayerDto {
    - username: String
    - email: String
    - password: String
    - passwordConfirm: String
    - roles: String[]
}

class RoleDto {
    - name: String
}

class AnswerDto {
    - id: Long
    - text: String
    - correct: boolean
}

class CategoryDto {
    - id: Long
    - name: String
    - description: String
    - questions: List<QuestionDto>
}

class QuestionDto {
    - id: Long
    - statement: String
    - options: List<AnswerDto>
    - correctAnswer: AnswerDto
    - category: CategoryDto
}

class AbstractGeographyGenerator {
    + getCategory(): Category
}

class BorderQuestionGenerator {
    - usedCountries: Set<String>
    + getAllBorderingCountries(resultsNode: JsonNode, correctCountry: String): List<String>
    + selectRandomIncorrectBorderingCountries(allBorderingCountries: List<String>, correctCountry: String, count: int): List<String>
    + generateOptions(results: JsonNode, result: JsonNode): List<String>
    + generateCorrectAnswer(result: JsonNode): String
    + getQuestionSubject(result: JsonNode): String
    + getQuery(): String
}

class CapitalQuestionGenerator {
    + getQuery(): String
    + getAllCapitals(resultsNode: JsonNode, correctCapital: String): List<String>
    + selectRandomIncorrectCapitals(allCapitals: List<String>, correctCapital: String, count: int): List<String>
    + generateOptions(results: JsonNode, result: JsonNode): List<String>
    + generateCorrectAnswer(result: JsonNode): String
    + getQuestionSubject(result: JsonNode): String
}

class ContinentQuestionGeneration {
    + getAllContinents(resultsNode: JsonNode, correctContinent: String): List<String>
    + selectRandomIncorrectContinents(allContinents: List<String>, correctContinent: String, count: int): List<String>
    + generateOptions(results: JsonNode, result: JsonNode): List<String>
    + generateCorrectAnswer(result: JsonNode): String
    + getQuestionSubject(result: JsonNode): String
    + getQuery(): String
}

class AbstractQuestionGenerator {
    - questions: List<Question>
    - categoryService: CategoryService
    - query: String
    - statement: String
    + questionGenerator(statement: String, options: List<String>, correctAnswer: String, category: Category): void
    + getQuestions(): List<Question>
    + generateOptions(results: JsonNode, result: JsonNode): List<String>
    + generateCorrectAnswer(result: JsonNode): String
    + getQuestionSubject(result: JsonNode): String
}

interface QuestionGenerator {
    + getQuery(): String
    + getQuestions(): List<Question>
    + getCategory(): Category
}

class CustomAuthenticationFailureHandler {
    + onAuthenticationFailure(request: HttpServletRequest, responde: HttpServletResponse, exception: AuthenticationException): void
}

class QuestionGeneratorTestController {
    + qgen: CapitalQuestionGenerator
    + test(): void
}

class CustomConfiguration {
    + localeResolver(): LocaleResolver
    + localeChangeInterceptor(): LocaleChangeInterceptor
    + addInterceptors(registry: InterceptorRegistry): void
}

class SecurityConfig {
    - userDetailsService: UserDetailsService
    - customAuthenticationFailureHandler: CustomAuthenticationFailureHandler
    + passwordEncoder(): PasswordEncoder
    + filterChain(http: HttpSecurity): SecurityFilterChain
    + configureGlobal(auth: AuthenticationManagerBuilder): void
    + isAuthenticated(): boolean
}

class CustomErrorController {
    + error(model: Model, webRequest: HttpServletRequest): String
}

class HomeController {
    - playerService: PlayerService
    + home(): String
    + apiHome(): String
}

class PlayersController {
    - playerService: PlayerService
    - signUpValidator: SignUpValidator
    + showRegistrationForm(model: Model): String
    + registerUserAccount(request: HttpServletRequest, user: PlayerDto, result: BindingResult, model: Model): String
    + showLoginForm(model: Model, error: String, session: HttpSession): String
    + home(model: Model, principal: Principal): String
}

class RestApiController {
    - apiKeyService: ApiKeyService
    - restApiService: RestApiService
    + getPlayers(response: HttpServletResponse, params: Map<String, String>): String
    + getQuestions(response: HttpServletResponse, params: Map<String, String>): String
    + getApiKeyFromParams(params: Map<String, String>): String
}

class WiqEs04bApplication {
    + main(args: String[]): void
}

JsonEntity <|.. Answer
JsonEntity <|.. Category
JsonEntity <|.. GameSession
JsonEntity <|.. Player
JsonEntity <|.. Question
AnswerRepository --|> CrudRepository
ApiKeyRepository --|> CrudRepository
CategoryRepository --|> CrudRepository
GameSessionRepository --|> CrudRepository
PlayerRepository --|> CrudRepository
QuestionRepository --|> CrudRepository
RestApiLogRepository --|> CrudRepository
RoleRepository --|> CrudRepository
AnswerService <|.. AnswerServiceImpl
ApiKeyService <|.. ApiKeyServiceImpl
CategoryService <|.. CategoryServiceImpl
PlayerService <|.. PlayerServiceImpl
QuestionService <|.. QuestionServiceImpl
RestApiService <|.. RestApiServiceImpl
RoleService <|.. RoleServiceImpl
Associations +-- PlayerRole
Associations +-- PlayerApiKey
Associations +-- ApiKeyAccessLog
Associations +-- PlayerGameSession
Associations +-- QuestionAnswers
AbstractGeographyGenerator --|> AbstractQuestionGenerator
BorderQuestionGenerator --|> AbstractGeographyGenerator
CapitalQuestionGenerator --|> AbstractGeographyGenerator
ContinentQuestionGeneration --|> AbstractGeographyGenerator
QuestionGenerator <|.. AbstractQuestionGenerator
CustomAuthenticationFailureHandler --|> SimpleUrlAuthenticationFailureHandler
WebMvcConfigurer <|.. CustomConfiguration
CustomErrorController --|> BasicErrorController

Question "1" *- "1" Category
GameSession "*" *-- "1" Player
Role "*" - "*" Player
PlayerService ..> Player
RoleService ..> Role
PlayerService ..> PlayerDto
PlayerServiceImpl ..> PlayerRepository
RoleServiceImpl .> RoleRepository
RoleService ..> RoleDto
@enduml
----

[plantuml, domain-model-2, svg]
----
@startuml
class WiqEs04bApplication {
    + main(args: String[]): void
}
class CustomErrorController {
   + error(model: Model, webRequest: HttpServletRequest): String
}

class HomeController {
    + home(model: Model): String
}

class PlayersController {
    + showRegistrationForm(model: Model): String
    + registerUserAccount(user: PlayerDto, result: BindingResult, model: Model): String
    + showLoginForm(model: Model, error: String, session: HttpSession): String
    + home(model: Model, principal: Principal): String
}

class SecurityConfig {
    + passwordEncoder(): PasswordEncoder
    + filterChain(http: HttpSecurity): SecurityFilterChain
    + configureGlobal(auth: AuthenticationManagerBuilder): void
    + isAuthenticated(): boolean
}

class CustomAuthenticationFailureHandler {
    + onAuthenticationFailure(request: HttpServletRequest, response: HttpServletResponse, exception: AuthenticationException): void
}

@enduml
----

=== Hexagonal Architecture

Our application is structured using hexagonal architecture principles, which prioritize the separation of core logic from peripheral concerns like user interface and external API interactions.

.Explanation:
This architecture facilitates the creation of a flexible and maintainable codebase. It allows for easy adaptation to changes in external services or user interface technologies without impacting the application's core logic.

=== Java Persistence API (JPA) for Data Management

We use JPA for data persistence to abstract and handle all database operations, allowing for a more streamlined and object-oriented approach to data handling.

.Explanation:
JPA enables us to map our domain objects to the database schema with ease, providing a clear layer of abstraction that simplifies data persistence and retrieval while ensuring our application remains agnostic of the underlying database technology.

=== Logging with Slf4j and System.out

For monitoring runtime behavior and troubleshooting, the project utilizes Slf4j, bundled with Sprint Boot, and System.out for logging. While Slf4j offers more sophisticated logging capabilities, System.out is used for straightforward, immediate console output.

.Explanation:
Slf4j is configured to capture various levels of output, which can be directed to multiple destinations such as console, files, or even remote logging servers. For simplicity and immediacy during development or less complex deployment scenarios, System.out is employed for logging output directly to the console.

=== Security

Security is a key concern, ensuring that user data and game integrity are protected. We implement standard security practices at various levels within the application

.Explanation:
This includes securing the web layer with Spring Security, encrypting sensitive data, and protecting against common web vulnerabilities.

=== Performance Optimization

Performance optimization is considered in all aspects of the application, from the efficient design of the domain model to the configuration of the persistence layer.

.Explanation:
We ensure that database interactions are efficient through JPA's caching and lazy loading. Queries are optimized to fetch only the necessary data, minimizing response times and resource utilization.

=== Continuous Integration and Continuous Deployment (CI/CD)

The project adheres to CI/CD practices, facilitating automated testing, building, and deployment processes which contribute to the robustness and reliability of the application.

.Explanation:
Our CI/CD pipeline automates the process of integrating code changes, building the application, running tests, and deploying the Dockerized application, ensuring consistent and reliable delivery of updates.

=== Scalability

Designing for scalability, the application can accommodate an increasing number of users and interactions without performance degradation.
.Explanation:
Scalable solutions such as Docker containers allow the application to be deployed in a distributed environment, where resources can be adjusted based on demand.